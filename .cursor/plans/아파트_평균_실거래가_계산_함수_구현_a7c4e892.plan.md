---
name: ""
overview: ""
todos: []
isProject: false
---

# 아파트 평균 실거래가 계산 함수 구현

**작성일**: 2026-02-17
**상태**: ✅ 완료
**담당**: Leena (AI 지원)

---

## 📋 개요

Supabase 데이터베이스에 아파트 평균 실거래가를 계산하는 PostgreSQL 함수를 구현했습니다. Codex가 제공한 초안을 검토하고, 실제 테이블 구조에 맞춰 수정 및 보안 강화를 진행했습니다.

---

## 🎯 목표

1. 아파트별 평균 실거래가 계산
2. 이상치 제거 (IQR 방식)
3. 저층 거래 필터링 (예외 허용)
4. 평균 단가(㎡당) 계산
5. 보안 강화

---

## ❌ 원본 코드 문제점

### 1. 치명적 오류: 존재하지 않는 컬럼 참조

```sql
-- ❌ apt_sales 테이블에 is_auction 컬럼이 없음
coalesce(is_auction, false) as is_auction
```

**원인**: 공공데이터포털 API는 경매 정보를 제공하지 않음

### 2. 컬럼명 불일치

```sql
-- ❌ 잘못된 파라미터/컬럼명
p_area_num numeric
area_num::numeric as area_m2

-- ✅ 실제 구조
area numeric  -- apt_sales 테이블의 실제 컬럼명
```

### 3. 보안 취약점

- **View**: `SECURITY DEFINER` 기본값 (권한 상승 위험)
- **Function**: `search_path` 미설정 (SQL 인젝션 위험)

### 4. 불필요한 타입 캐스팅

```sql
-- ❌ 이미 해당 타입인데 캐스팅
deal_date::date  -- 이미 date 타입
floor::int       -- 이미 integer 타입
```

---

## ✅ 최종 구현

### 1. View 생성 (보안 강화)

```sql
CREATE OR REPLACE VIEW public.v_apt_sales_normalized
WITH (security_invoker = true) AS  -- 🔒 보안: 호출자 권한으로 실행
SELECT
  lawd_code,
  apt_name,
  area AS area_m2,
  deal_date,
  deal_amount,
  floor
FROM public.apt_sales
WHERE deal_amount > 0;
```

**개선사항**:

- `security_invoker = true`: View 생성자가 아닌 호출자 권한으로 실행
- 실제 컬럼명(`area`) 사용
- 불필요한 타입 캐스팅 제거

### 2. 평균 실거래가 계산 함수

```sql
CREATE OR REPLACE FUNCTION public.get_apt_avg_price(
  p_lawd_code text,
  p_apt_name text,
  p_area numeric DEFAULT NULL,
  p_low_floor_max int DEFAULT 1
)
RETURNS TABLE (
  target_month date,
  avg_deal_amount numeric,
  avg_unit_price numeric,
  sample_count int
)
LANGUAGE sql
STABLE
SET search_path = ''  -- 🔒 보안: SQL 인젝션 방지
AS $$
WITH src AS (
  -- 기본 데이터 필터링
  SELECT *
  FROM public.v_apt_sales_normalized
  WHERE lawd_code = p_lawd_code
    AND apt_name = p_apt_name
    AND (p_area IS NULL OR area_m2 = p_area)
),
latest AS (
  -- 최근 거래 월 찾기
  SELECT date_trunc('month', MAX(deal_date))::date AS month_start
  FROM src
),
month_rows AS (
  -- 최근 월 거래만 추출
  SELECT s.*, l.month_start
  FROM src s
  CROSS JOIN latest l
  WHERE l.month_start IS NOT NULL
    AND s.deal_date >= l.month_start
    AND s.deal_date < l.month_start + INTERVAL '1 month'
),
prev3 AS (
  -- 이전 3개월 거래 데이터
  SELECT s.*
  FROM src s
  JOIN latest l ON true
  WHERE s.deal_date >= l.month_start - INTERVAL '3 month'
    AND s.deal_date < l.month_start
),
prev3_stats AS (
  -- 이전 3개월 통계
  SELECT
    COUNT(*) AS cnt,
    MAX(deal_amount) AS max_amt
  FROM prev3
),
iqr AS (
  -- 사분위수 계산 (이상치 제거용)
  SELECT
    PERCENTILE_CONT(0.25) WITHIN GROUP (ORDER BY deal_amount) AS q1,
    PERCENTILE_CONT(0.75) WITHIN GROUP (ORDER BY deal_amount) AS q3
  FROM month_rows
),
filtered AS (
  SELECT m.*
  FROM month_rows m
  CROSS JOIN prev3_stats p
  CROSS JOIN iqr
  WHERE
    -- 저층 제외 + 예외 허용
    (
      m.floor > p_low_floor_max          -- 일반: 저층 제외
      OR p.cnt = 0                        -- 예외1: 이전 3개월 거래 없음
      OR m.deal_amount > p.max_amt        -- 예외2: 이전 최고가 초과
    )
    -- IQR 이상값 제거
    AND (
      iqr.q1 IS NULL OR iqr.q3 IS NULL OR iqr.q1 = iqr.q3
      OR m.deal_amount BETWEEN (iqr.q1 - 1.5 * (iqr.q3 - iqr.q1))
                           AND (iqr.q3 + 1.5 * (iqr.q3 - iqr.q1))
    )
)
SELECT
  (SELECT month_start FROM latest) AS target_month,
  ROUND(AVG(deal_amount)) AS avg_deal_amount,
  ROUND(SUM(deal_amount) / NULLIF(SUM(area_m2), 0), 2) AS avg_unit_price,
  COUNT(*)::int AS sample_count
FROM filtered;
$$;

COMMENT ON FUNCTION public.get_apt_avg_price IS '
아파트 평균 실거래가 계산 함수 (보안 강화)
- 최근 월의 거래 데이터를 기준으로 평균 거래가와 평균 단가를 계산
- 저층 거래 제외 (단, 이전 3개월 거래가 없거나 최고가를 초과하는 경우 포함)
- IQR 방식으로 이상치 제거
- 보안: search_path 고정, security_invoker 설정
';
```

---

## 🔄 View와 데이터 흐름 이해하기

### View란 무엇인가?

**View는 실제 데이터를 저장하지 않습니다.** View는 "저장된 쿼리(Saved Query)"입니다.

```sql
CREATE OR REPLACE VIEW public.v_apt_sales_normalized AS
SELECT
  lawd_code,
  apt_name,
  area AS area_m2,
  deal_date,
  deal_amount,
  floor
FROM public.apt_sales        -- 👈 이 테이블의 데이터를 보여줌
WHERE deal_amount > 0;
```

### 📊 비유로 이해하기

```
apt_sales 테이블 (실제 창고)
└─ 25,761개의 상자 (실제 데이터 저장)

v_apt_sales_normalized (창고 입구의 창문)
└─ 창문을 통해 보면 약 25,000개의 상자가 보임
   (deal_amount > 0인 것만 필터링)
└─ 창문 자체에는 상자가 없음! (데이터 저장 안 함)
└─ 창문을 열 때마다 실시간으로 창고 내부를 확인
```

### View의 장점

1. **컬럼명 매핑**
  ```sql
   area AS area_m2  -- 'area'를 'area_m2'로 보여줌
  ```
2. **필터링**
  ```sql
   WHERE deal_amount > 0  -- 잘못된 데이터 제외
  ```
3. **보안**
  ```sql
   -- apt_sales의 created_at, updated_at 같은 메타데이터 숨김
  ```
4. **재사용성**
  ```sql
   -- 여러 함수에서 동일한 필터링 로직 재사용
   SELECT * FROM v_apt_sales_normalized
  ```

### 실제 데이터 흐름

```
[1] 사용자
    아파트명 "보원" 입력
    ↓

[2] 프론트엔드 (TypeScript)
    const { data } = await supabase.rpc('get_apt_avg_price', {
      p_lawd_code: '41465',
      p_apt_name: '보원',
      p_area: 59.72,
      p_low_floor_max: 1
    })
    ↓

[3] Supabase PostgreSQL 함수
    get_apt_avg_price() 실행 시작
    ↓

[4] View 조회 (실시간)
    SELECT * FROM v_apt_sales_normalized
    WHERE lawd_code = '41465'
      AND apt_name = '보원'
      AND area_m2 = 59.72

    👆 이 순간 실제로는 아래 쿼리 실행:
    SELECT lawd_code, apt_name, area AS area_m2, ...
    FROM apt_sales  -- 원본 테이블
    WHERE deal_amount > 0
      AND lawd_code = '41465'
      AND apt_name = '보원'
      AND area = 59.72
    ↓

[5] 함수 내부 계산
    - 최근 월 찾기: 2026-02-01
    - 이전 3개월 통계
    - IQR 이상치 제거
    - 저층 필터링
    ↓

[6] 결과 반환
    {
      target_month: '2026-02-01',
      avg_deal_amount: 72560,  // 만원
      avg_unit_price: 1215.00, // 만원/㎡
      sample_count: 5
    }
    ↓

[7] UI 표시
    평균 실거래가: 72,560만원
    평균 단가: 1,215만원/㎡
    (5건 기준)
```

### 실시간 계산 메커니즘

**핵심: 모든 것이 실시간으로 계산됩니다!**

```sql
-- 사용자가 "보원" 검색할 때마다
WITH src AS (
  SELECT *
  FROM v_apt_sales_normalized  -- 👈 실시간 조회
  WHERE apt_name = '보원'
),
latest AS (
  SELECT MAX(deal_date)  -- 👈 지금 이 순간의 최신 데이터
  ...
)
```

### View vs Materialized View


| 항목     | View (우리가 사용) | Materialized View |
| ------ | ------------- | ----------------- |
| 데이터 저장 | ❌ 저장 안 함      | ✅ 실제 복사본 저장       |
| 최신성    | ✅ 항상 최신       | ❌ REFRESH 필요      |
| 속도     | 일반            | 빠름                |
| 용량     | 0 (추가 없음)     | 2배 (복사본)          |
| 사용 케이스 | 실시간 데이터       | 집계/통계             |


### 왜 View를 사용했나?

#### ❌ View 없이 작성한다면:

```sql
-- 함수 1
CREATE FUNCTION get_apt_avg_price(...) AS $$
WITH src AS (
  SELECT
    lawd_code,
    apt_name,
    area AS area_m2,  -- 👈 중복1
    deal_date,
    deal_amount,
    floor
  FROM apt_sales
  WHERE deal_amount > 0  -- 👈 중복2
    AND lawd_code = p_lawd_code
    ...
)
$$;

-- 함수 2
CREATE FUNCTION get_apt_price_trend(...) AS $$
WITH src AS (
  SELECT
    lawd_code,
    apt_name,
    area AS area_m2,  -- 👈 또 중복1
    deal_date,
    deal_amount,
    floor
  FROM apt_sales
  WHERE deal_amount > 0  -- 👈 또 중복2
    ...
)
$$;
```

#### ✅ View를 사용하면:

```sql
-- 1. View 한 번만 정의
CREATE VIEW v_apt_sales_normalized AS
SELECT ... WHERE deal_amount > 0;

-- 2. 여러 함수에서 재사용
CREATE FUNCTION get_apt_avg_price(...) AS $$
  SELECT * FROM v_apt_sales_normalized WHERE ...
$$;

CREATE FUNCTION get_apt_price_trend(...) AS $$
  SELECT * FROM v_apt_sales_normalized WHERE ...
$$;
```

### 프론트엔드 통합 예시

```typescript
// AssetList.tsx에서
const handleApartmentSelect = async (aptName: string) => {
  // 1. Supabase 함수 호출
  const { data, error } = await supabase.rpc('get_apt_avg_price', {
    p_lawd_code: selectedLocation,
    p_apt_name: aptName,
    p_area: selectedArea,
    p_low_floor_max: 1
  });

  // 2. 결과 받아서 표시
  if (data && data.length > 0) {
    const result = data[0];
    console.log(`평균 실거래가: ${result.avg_deal_amount.toLocaleString()}만원`);
    console.log(`평균 단가: ${result.avg_unit_price.toLocaleString()}만원/㎡`);
    console.log(`데이터 개수: ${result.sample_count}건`);

    // UI 업데이트
    setApartmentPrice({
      avgPrice: result.avg_deal_amount,
      unitPrice: result.avg_unit_price,
      sampleCount: result.sample_count
    });
  }
};
```

### 정리


| 항목          | 설명                             |
| ----------- | ------------------------------ |
| **사용자 입력**  | 아파트명 "보원"                      |
| **View 역할** | `apt_sales` 테이블을 깔끔하게 조회 (실시간) |
| **함수 역할**   | View 데이터로 평균, IQR, 필터링 계산      |
| **결과**      | 최신 데이터 기반 평균 실거래가              |
| **데이터 저장**  | View는 데이터를 저장하지 않음             |
| **성능**      | 매번 실시간 조회 (캐싱은 프론트엔드에서)        |


**View는 "창문"입니다. 매번 열 때마다 실시간으로 `apt_sales` 창고를 들여다봅니다!** 🪟

---

## 🧪 테스트 결과

### 테스트 케이스 1: 거래량이 적은 아파트

```sql
SELECT * FROM public.get_apt_avg_price(
  '11200',                    -- 법정동코드 (성동구)
  '래미안 옥수 리버젠',
  134.13,                     -- 면적 (㎡)
  1                           -- 저층 기준 (1층 이하)
);
```

**결과**:


| target_month | avg_deal_amount | avg_unit_price | sample_count |
| ------------ | --------------- | -------------- | ------------ |
| 2026-02-01   | 314,500만원       | 2,344.74만원/㎡   | 1건           |


### 테스트 케이스 2: 거래량이 많은 아파트

```sql
SELECT * FROM public.get_apt_avg_price(
  '41465',                    -- 법정동코드 (용인시)
  '보원',
  59.72,
  1
);
```

**결과**:


| target_month | avg_deal_amount | avg_unit_price | sample_count |
| ------------ | --------------- | -------------- | ------------ |
| 2026-02-01   | 72,560만원        | 1,215.00만원/㎡   | 5건           |


**원본 데이터 검증**:

```
거래일자    층   거래금액(만원)
2026-02-06  12   74,300
2026-02-05   5   71,000
2026-02-04  14   74,500
2026-02-03  14   70,000
2026-02-01  14   73,000

평균: 72,560만원 ✅ 정확
```

---

## 🔒 보안 검증

Supabase Database Advisor 검사 결과:

### 수정 전

- ❌ `v_apt_sales_normalized`: SECURITY DEFINER 경고
- ❌ `get_apt_avg_price`: search_path mutable 경고

### 수정 후

- ✅ `v_apt_sales_normalized`: 보안 경고 없음
- ✅ `get_apt_avg_price`: 보안 경고 없음

---

## 📊 알고리즘 평가

### ✅ 우수한 점

1. **IQR 방식 이상치 제거**
  - Q1 - 1.5 × IQR ~ Q3 + 1.5 × IQR 범위 사용
  - 통계적으로 검증된 방법
2. **저층 제외 + 예외 허용**
  - 기본: 저층(1층 이하) 제외
  - 예외1: 이전 3개월 거래 없을 때 포함
  - 예외2: 이전 최고가 초과 시 포함
  - → 실무적으로 합리적인 접근
3. **평균 단가 계산**
  - 총 거래금액 ÷ 총 면적 = 정확한 평균 단가

### ⚠️ 제한사항

1. **경매 제외 불가**: 데이터 소스 특성상 구현 불가
2. **최근 월만 분석**: 과거 추세 분석 부재
3. **샘플 수 적을 때**: 신뢰도 저하 가능성

---

## 💡 향후 개선 제안

### 1. 신뢰도 지표 추가

```sql
-- sample_count가 적을 때 경고 플래그 추가
CASE
  WHEN COUNT(*) < 3 THEN '낮음'
  WHEN COUNT(*) < 10 THEN '보통'
  ELSE '높음'
END as confidence_level
```

### 2. 과거 추세 분석 함수

```sql
-- 최근 N개월 평균 추세 제공
CREATE FUNCTION get_apt_price_trend(
  p_lawd_code text,
  p_apt_name text,
  p_area numeric,
  p_months int DEFAULT 3
) ...
```

### 3. 성능 최적화 인덱스

```sql
-- 복합 인덱스 추가로 조회 속도 개선
CREATE INDEX IF NOT EXISTS idx_apt_sales_lookup
ON apt_sales(lawd_code, apt_name, area, deal_date DESC);
```

### 4. 캐싱 전략

```typescript
// Next.js에서 5분 캐싱
export async function getAptAvgPrice(...) {
  return await supabase.rpc('get_apt_avg_price', params, {
    next: { revalidate: 300 }  // 5분 캐시
  });
}
```

---

## 📚 관련 파일

### Backend (Supabase)

- **Migration**: `supabase/migrations/create_apt_avg_price_function.sql`
- **View**: `public.v_apt_sales_normalized` (25.6k rows - 실시간 조회)
- **Function**: `public.get_apt_avg_price()`
- **테이블**: `public.apt_sales` (25,761 rows)

### Frontend

- **Component**: `src/components/AssetList.tsx` (아파트 선택 UI)
- **사용 예시**:
  ```typescript
  const { data } = await supabase.rpc('get_apt_avg_price', {
    p_lawd_code: '41465',
    p_apt_name: '보원',
    p_area: 59.72,
    p_low_floor_max: 1
  });
  ```

---

## 🎓 학습 포인트

1. **View의 개념 이해**
  - View는 데이터를 저장하지 않는 "저장된 쿼리"
  - 실시간으로 원본 테이블을 조회
  - Materialized View와의 차이점
  - 코드 재사용과 유지보수 향상
2. **실제 데이터 구조 확인 필수**
  - AI 생성 코드라도 반드시 검증 필요
  - `information_schema.columns` 활용
  - Supabase에서 직접 테이블 구조 확인
3. **PostgreSQL 보안 모범 사례**
  - View: `security_invoker = true`
  - Function: `SET search_path = ''`
  - RLS 정책과의 상호작용
4. **통계적 이상치 제거**
  - IQR 방식의 원리와 구현
  - `PERCENTILE_CONT()` 함수 활용
  - Q1 - 1.5×IQR ~ Q3 + 1.5×IQR 범위
5. **비즈니스 로직과 통계의 조화**
  - 저층 제외 규칙 + 예외 허용
  - 단순 통계가 아닌 실무 적용 가능한 로직
  - 도메인 지식을 알고리즘에 반영

---

## ✅ 체크리스트

- 테이블 구조 확인 (`apt_sales` 스키마 검증)
- View 생성 및 보안 설정 (`security_invoker = true`)
- 함수 구현 (IQR 이상치 제거 + 저층 필터링)
- 보안 검증 (`search_path`, `security_invoker`)
- View 개념 이해 (실시간 조회, 데이터 미저장)
- 데이터 흐름 파악 (프론트엔드 → Supabase → View → 계산)
- 테스트 케이스 실행 (거래량 많음/적음)
- Supabase Advisor 검사 통과
- 문서화 완료 (View 설명 포함)

---

**최종 결론**: 프로덕션 환경에서 안전하게 사용 가능합니다. ✅
