---
name: 클라이언트 캐싱 구현
overview: Yahoo Finance API 호출을 최적화하기 위해 클라이언트 측 로컬 스토리지 캐싱 레이어를 추가하고, 중복 요청 방지 기능을 구현합니다. 이를 통해 동일 티커에 대한 중복 호출을 방지하고 응답 속도를 개선하며, 페이지 새로고침 후에도 캐시를 유지합니다.
todos:
  - id: create-quote-cache
    content: src/services/quoteCache.ts 파일 생성 - QuoteData 타입 정의 및 QuoteCache 클래스 구현 (로컬 스토리지 기반, 캐시 TTL 5분, 중복 요청 방지, 오래된 데이터 자동 삭제, 에러 시 pendingRequests 정리, forceRefresh 옵션)
    status: pending
  - id: update-price-api
    content: src/services/priceApi.ts 수정 - fetchStockPrice 함수가 quoteCache.getQuote()를 사용하도록 변경
    status: pending
    dependencies:
      - create-quote-cache
  - id: update-stock-card
    content: src/components/StockCard.tsx 수정 - fetchStockPrice 함수가 quoteCache.getQuote()를 사용하도록 변경
    status: pending
    dependencies:
      - create-quote-cache
  - id: update-asset-form
    content: src/components/AssetForm.tsx 수정 - useEffect 내부 API 호출이 quoteCache.getQuote()를 사용하도록 변경
    status: pending
    dependencies:
      - create-quote-cache
---

# 클라이언트 캐싱 구현 계획

## 목표

Yahoo Finance API 호출 최적화를 위해 클라이언트 측 로컬 스토리지 캐싱 레이어를 추가하여:

- 동일 티커에 대한 중복 API 호출 방지
- 캐시된 데이터 재사용으로 응답 속도 개선
- 페이지 새로고침 후에도 캐시 유지
- 서버 부하 감소

## 구현 단계

### 1. 캐시 서비스 생성

**파일**: `src/services/quoteCache.ts` (신규 생성)

- `QuoteData` 인터페이스 정의 (API 응답 구조와 일치)
- `QuoteCache` 클래스 구현:
- 로컬 스토리지 기반 캐시 저장소 (localStorage API 사용)
- TTL 관리 (5분 = 300초)
- 중복 요청 방지 (`Map<string, Promise<QuoteData>>` - 메모리 기반)
- `getQuote(symbol: string, forceRefresh?: boolean)` 메서드:
    - `forceRefresh`가 true면 캐시 무시하고 API 호출
    - 로컬 스토리지에서 캐시 확인 (TTL 체크)
    - 중복 요청 확인 (pendingRequests)
    - API 호출 및 로컬 스토리지에 캐시 저장
    - 에러 발생 시 `finally` 블록에서 pendingRequests에서 삭제
- `clear()` 메서드: 로컬 스토리지 캐시 초기화 (선택적)
- `_loadFromStorage()`: 로컬 스토리지에서 전체 캐시 로드 (초기화 시 호출)
- `_saveToStorage()`: 로컬 스토리지에 캐시 저장 (JSON 직렬화)
- `_pruneCache()`: 오래된 데이터 자동 삭제 (5분 지난 데이터 제거)
    - `_saveToStorage()` 호출 전에 실행
    - 앱 초기화 시에도 실행

**핵심 로직**:

```typescript
// 1. forceRefresh 옵션 확인 (true면 캐시 무시)
// 2. 로컬 스토리지에서 캐시 확인 (TTL 체크)
// 3. 중복 요청 방지 (pendingRequests 확인)
// 4. API 호출 및 로컬 스토리지에 캐시 저장
// 5. _pruneCache() 실행 (오래된 데이터 삭제)
// 6. 에러 처리 및 finally 블록에서 pendingRequests 정리
```

**보완 사항**:

1. **오래된 데이터 자동 삭제 (Pruning)**:

- `_pruneCache()` 메서드: 5분(300초)이 지난 캐시 항목 자동 삭제
- `_saveToStorage()` 호출 전에 실행
- 클래스 초기화 시에도 실행하여 localStorage 용량 관리
- 구현 로직:
     ```typescript
               private _pruneCache(): void {
                 const now = Date.now();
                 const ttl = 300 * 1000; // 5분
                 const cache = this._loadFromStorage();
                 Object.keys(cache).forEach(symbol => {
                   if (now - cache[symbol].timestamp > ttl) {
                     delete cache[symbol];
                   }
                 });
                 this._saveToStorage(cache);
               }
     ```




2. **실패 시 약속 취소 (Error Cleanup)**:

- API 호출 실패 시 `finally` 블록에서 `pendingRequests.delete(symbol)` 실행
- 재시도 가능하도록 보장
- 구현 예시:
     ```typescript
               try {
                 const response = await fetch(`/api/quote?symbol=${symbol}`);
                 // ... 처리
               } catch (error) {
                 throw error;
               } finally {
                 this.pendingRequests.delete(symbol); // 반드시 정리
               }
     ```




3. **강제 새로고침 옵션 (Force Refresh)**:

- `getQuote(symbol: string, forceRefresh?: boolean)` 시그니처
- `forceRefresh: true`일 때 캐시 무시하고 무조건 API 호출
- 사용 예시: `quoteCache.getQuote('AAPL', true)` - 최신 데이터 강제 조회

**로컬 스토리지 키**: `wealth-dash-quote-cache`**저장 형식**: JSON 객체

```typescript
{
  [symbol: string]: {
    data: QuoteData;
    timestamp: number;
  }
}
```



### 2. priceApi.ts 수정

**파일**: `src/services/priceApi.ts`

- `quoteCache` import 추가
- `fetchStockPrice` 함수 수정:
- 직접 `fetch` 호출 대신 `quoteCache.getQuote()` 사용
- 반환값에서 `price` 필드만 추출하여 반환
- 기존 에러 처리 로직 유지

### 3. StockCard.tsx 수정

**파일**: `src/components/StockCard.tsx`

- `quoteCache` import 추가
- `fetchStockPrice` 함수 수정:
- 직접 `fetch` 호출 대신 `quoteCache.getQuote()` 사용
- 응답 데이터를 `StockData` 형태로 변환하여 `setStockData` 호출
- 기존 에러 처리 및 로딩 상태 관리 로직 유지

### 4. AssetForm.tsx 수정

**파일**: `src/components/AssetForm.tsx`

- `quoteCache` import 추가
- `useEffect` 내부의 API 호출 로직 수정:
- 직접 `fetch` 호출 대신 `quoteCache.getQuote()` 사용
- 응답에서 `name` 필드 추출하여 `setName` 호출
- 기존 debounce 로직 (800ms) 및 에러 처리 유지

## 데이터 흐름

```javascript
사용자 요청
  ↓
quoteCache.getQuote(symbol, forceRefresh?)
  ↓
forceRefresh === true?
  ├─ Yes → 캐시 무시, 바로 API 호출
  └─ No → 로컬 스토리지에서 캐시 확인 (TTL 체크)
      ├─ 캐시 히트 (5분 이내) → 즉시 반환
      └─ 캐시 미스
          ↓
중복 요청 확인 (pendingRequests)
  ├─ 진행 중인 요청 있음 → 같은 Promise 반환
  └─ 새로운 요청
      ↓
/api/quote API 호출
  ↓
응답 받아서 로컬 스토리지에 캐시 저장
  ↓
_pruneCache() 실행 (오래된 데이터 삭제)
  ↓
finally 블록에서 pendingRequests 정리
  ↓
반환
```



## 타입 정의

### QuoteData 인터페이스

```typescript
interface QuoteData {
  symbol: string;
  price: number;
  currency?: string;
  name?: string;
  changePercent?: number;
}

interface CachedQuote extends QuoteData {
  timestamp: number;
}
```



## 캐시 전략

- **TTL**: 5분 (300초)
- **저장소**: 로컬 스토리지 (페이지 새로고침 후에도 유지)
- **중복 방지**: 동일 티커에 대한 동시 요청을 하나의 Promise로 공유 (메모리 기반)
- **직렬화**: JSON.stringify/parse 사용
- **에러 처리**: 로컬 스토리지 접근 실패 시 메모리 캐시로 폴백

## 예상 효과

- 중복 호출 제거: 동일 티커에 대한 동시 요청이 하나의 API 호출로 통합
- 응답 속도 개선: 캐시 히트 시 즉시 반환 (10-50ms)
- 서버 부하 감소: 불필요한 API 호출 방지

## 주의사항

- 로컬 스토리지 사용 시 브라우저 저장 공간 제한 고려 (일반적으로 5-10MB)
- `_pruneCache()`를 통해 오래된 데이터 자동 삭제로 용량 관리
- 로컬 스토리지 접근 실패 시 (예: 시크릿 모드, 저장 공간 부족) 메모리 캐시로 폴백
- 서버 측 HTTP 캐시와 함께 작동하여 이중 캐싱 효과
- 에러 발생 시 `finally` 블록에서 반드시 `pendingRequests.delete(symbol)` 실행하여 재시도 가능하도록 보장